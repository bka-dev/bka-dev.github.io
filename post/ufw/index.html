<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    <title>
      
       - blog.kanbach.org
      
		</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="blog.kanbach.org" />
<meta name="twitter:creator" content="_bka_" />
<meta property="og:url" content="https://blog.kanbach.org/post/ufw/" />
<meta property="og:title" content="" />
<meta property="og:description" content=" IT-Security and stuff -  " />

    
    <link rel="stylesheet" type="text/css" href="/assets/css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/icons.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    
    <link href="https://fonts.loli.net/css?family=Bree+Serif|Lato:100,100i,300,300i,400,400i,700,700i|Source+Code+Pro:300,400,500,700" rel="stylesheet">
    

    
    <script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/bigfoot/dist/bigfoot.js"></script>
    <link rel="stylesheet" type="text/css" href="/assets/bigfoot/dist/bigfoot-number.css" />
    <script type="text/javascript">
        $.bigfoot();
    </script>
    
    
</head>

    <body class="post-template">
        <header class="main-header">
	<div class="main-header-content">
		<h1 class="blog-title">
			<a href="/">
				
           blog.kanbach.org
				
			</a>
		</h1>
		<h2 class="blog-description">IT-Security and stuff</h2>
	</div>

	<div class="nav">
    
		
      <a class="nav- " role="presentation" href="/post/escaping-from-mozilla-firefox-in-restricted-environments/">Escaping from Mozilla Firefox in Restricted Environments</a>
		
      <a class="nav- " role="presentation" href="/post/how-to-permanently-change-a-mac-address-using-ethtool/">How to permanently change a MAC address using ethtool</a>
		
      <a class="nav- " role="presentation" href="/post/network-security-implications-of-host-models/">Network Security Implications of Host Models</a>
		
      <a class="nav- " role="presentation" href="/about/">About</a>
		
	</div>
</header>

        
<main class="content" role="main">
  <article class="post">
    <header class="post-header">
      
      <h2 class="post-title"></h2>
      <section class="post-meta">
        <time class="post-date">0001-01-01</time>
      </section>
    </header>
    <section class="post-content">
      <h1 id="firewalls-under-the-hood--ufw">Firewalls under the hood - UFW</h1>
<h2 id="overview">Overview</h2>
<p>This blogpost aims to explain some of the inner workings of the &ldquo;uncomplicated firewall&rdquo; (UFW) that is available for Ubuntu installations since 8.04 LTS and for Debian installations since 10.</p>
<p>Before going into detail: UFW is not a firewall but a frontend for iptables, which itself could be considered a frontend for netfilter, that is performing packet filtering within the Linux kernel. Therefore all actions that are performed via UFW are directly visible in iptables output.</p>
<p>The following sections deal with the default configuration that UFW uses and describe how rule insertions are handled.</p>
<h2 id="default-rule-set-ipv4">Default rule set (IPv4)</h2>
<p>The following setup is based on a standard Linux kernel without any hardening measures and ufw version 0.36.1, released on 19 September 2021.</p>
<p>After enabling ufw with <code>ufw enable</code> let's use iptables to check what happened:</p>
<pre><code>$ iptables -S

-P INPUT DROP
-P FORWARD DROP
-P OUTPUT ACCEPT
-N ufw-after-forward
-N ufw-after-input
-N ufw-after-logging-forward
-N ufw-after-logging-input
-N ufw-after-logging-output
-N ufw-after-output
-N ufw-before-forward
-N ufw-before-input
-N ufw-before-logging-forward
-N ufw-before-logging-input
-N ufw-before-logging-output
-N ufw-before-output
-N ufw-logging-allow
-N ufw-logging-deny
-N ufw-not-local
-N ufw-reject-forward
-N ufw-reject-input
-N ufw-reject-output
-N ufw-skip-to-policy-forward
-N ufw-skip-to-policy-input
-N ufw-skip-to-policy-output
-N ufw-track-forward
-N ufw-track-input
-N ufw-track-output
-N ufw-user-forward
-N ufw-user-input
-N ufw-user-limit
-N ufw-user-limit-accept
-N ufw-user-logging-forward
-N ufw-user-logging-input
-N ufw-user-logging-output
-N ufw-user-output
-A INPUT -j ufw-before-logging-input
-A INPUT -j ufw-before-input
-A INPUT -j ufw-after-input
-A INPUT -j ufw-after-logging-input
-A INPUT -j ufw-reject-input
-A INPUT -j ufw-track-input
-A FORWARD -j ufw-before-logging-forward
-A FORWARD -j ufw-before-forward
-A FORWARD -j ufw-after-forward
-A FORWARD -j ufw-after-logging-forward
-A FORWARD -j ufw-reject-forward
-A FORWARD -j ufw-track-forward
-A OUTPUT -j ufw-before-logging-output
-A OUTPUT -j ufw-before-output
-A OUTPUT -j ufw-after-output
-A OUTPUT -j ufw-after-logging-output
-A OUTPUT -j ufw-reject-output
-A OUTPUT -j ufw-track-output
-A ufw-after-input -p udp -m udp --dport 137 -j ufw-skip-to-policy-input
-A ufw-after-input -p udp -m udp --dport 138 -j ufw-skip-to-policy-input
-A ufw-after-input -p tcp -m tcp --dport 139 -j ufw-skip-to-policy-input
-A ufw-after-input -p tcp -m tcp --dport 445 -j ufw-skip-to-policy-input
-A ufw-after-input -p udp -m udp --dport 67 -j ufw-skip-to-policy-input
-A ufw-after-input -p udp -m udp --dport 68 -j ufw-skip-to-policy-input
-A ufw-after-input -m addrtype --dst-type BROADCAST -j ufw-skip-to-policy-input
-A ufw-after-logging-forward -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;
-A ufw-after-logging-input -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;
-A ufw-before-forward -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A ufw-before-forward -p icmp -m icmp --icmp-type 3 -j ACCEPT
-A ufw-before-forward -p icmp -m icmp --icmp-type 11 -j ACCEPT
-A ufw-before-forward -p icmp -m icmp --icmp-type 12 -j ACCEPT
-A ufw-before-forward -p icmp -m icmp --icmp-type 8 -j ACCEPT
-A ufw-before-forward -j ufw-user-forward
-A ufw-before-input -i lo -j ACCEPT
-A ufw-before-input -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A ufw-before-input -m conntrack --ctstate INVALID -j ufw-logging-deny
-A ufw-before-input -m conntrack --ctstate INVALID -j DROP
-A ufw-before-input -p icmp -m icmp --icmp-type 3 -j ACCEPT
-A ufw-before-input -p icmp -m icmp --icmp-type 11 -j ACCEPT
-A ufw-before-input -p icmp -m icmp --icmp-type 12 -j ACCEPT
-A ufw-before-input -p icmp -m icmp --icmp-type 8 -j ACCEPT
-A ufw-before-input -p udp -m udp --sport 67 --dport 68 -j ACCEPT
-A ufw-before-input -j ufw-not-local
-A ufw-before-input -d 224.0.0.251/32 -p udp -m udp --dport 5353 -j ACCEPT
-A ufw-before-input -d 239.255.255.250/32 -p udp -m udp --dport 1900 -j ACCEPT
-A ufw-before-input -j ufw-user-input
-A ufw-before-output -o lo -j ACCEPT
-A ufw-before-output -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A ufw-before-output -j ufw-user-output
-A ufw-logging-allow -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW ALLOW] &quot;
-A ufw-logging-deny -m conntrack --ctstate INVALID -m limit --limit 3/min --limit-burst 10 -j RETURN
-A ufw-logging-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;
-A ufw-not-local -m addrtype --dst-type LOCAL -j RETURN
-A ufw-not-local -m addrtype --dst-type MULTICAST -j RETURN
-A ufw-not-local -m addrtype --dst-type BROADCAST -j RETURN
-A ufw-not-local -m limit --limit 3/min --limit-burst 10 -j ufw-logging-deny
-A ufw-not-local -j DROP
-A ufw-skip-to-policy-forward -j DROP
-A ufw-skip-to-policy-input -j DROP
-A ufw-skip-to-policy-output -j ACCEPT
-A ufw-track-output -p tcp -m conntrack --ctstate NEW -j ACCEPT
-A ufw-track-output -p udp -m conntrack --ctstate NEW -j ACCEPT
-A ufw-user-limit -m limit --limit 3/min -j LOG --log-prefix &quot;[UFW LIMIT BLOCK] &quot;
-A ufw-user-limit -j REJECT --reject-with icmp-port-unreachable
-A ufw-user-limit-accept -j ACCEPT
</code></pre><p>The output above shows the <strong>filter</strong> table, as it was populated by UFW. It comprises several new chains like <strong>ufw-after-forward</strong>, <strong>ufw-after-input</strong> and many more and a set of rules that are appended to both the builtin and custom chains.</p>
<p>The listing above only shows the filter table. Besides filter, netfilter also uses the tables <strong>raw</strong>, <strong>mangle</strong>, <strong>security</strong> and <strong>nat</strong>, which however remain untouched.</p>
<p>The filter table contains the builtin chains INPUT, OUTPUT and FORWARD and these chains are basically the ones that ufw is able to adjust.</p>
<p>Let's first take a look at how incoming network traffic is handled:</p>
<h2 id="input-handling-ipv4">Input handling (IPv4)</h2>
<p>Every input that is destined to the host itself traverses the INPUT chain. This builtin netfilter chain is populated by ufw with a series of custom chains as shown in the overview image below:</p>
<p><img src="ufw-input.png" alt="Default ufw rules for incoming IPv4 packets"></p>
<p>The first configuration that can be seen in the image above is a <strong>DROP</strong> policy for incoming packets. This means that every packet that traverses the whole INPUT chain and doesn't match any configured rule would be discarded by the kernel.</p>
<h3 id="ufwbeforelogginginput">ufw-before-logging-input</h3>
<p>First, incoming packets are sent to the target <strong>ufw-before-logging-input</strong>, which however, doesn't contain any rules.</p>
<h3 id="ufwbeforeinput">ufw-before-input</h3>
<p>The next chain that incoming packets are sent to is <strong>ufw-before-input</strong> and a lot is happening there:</p>
<p><code>-i lo -j ACCEPT</code></p>
<p>This rule accepts all packets that arrive on interface <strong>lo</strong>. This rule is in place to ensure that applications on the machine could use local communication via localnet (127.0.0.0/8).</p>
<p><code>-m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code></p>
<p><code>-m conntrack --ctstate INVALID -j ufw-logging-deny</code></p>
<p><code>-m conntrack --ctstate INVALID -j DROP</code></p>
<p>These rules examine the state of the identified packets and call the conntrack module for this. The first rule checks if the incoming packet is associated with the states <strong>RELATED</strong> or <strong>ESTABLISHED</strong>.</p>
<p>The <strong>ESTABLISHED</strong> state refers to connections in which traffic is exchanged in both directions. For TCP this is the case once the three-way handshake is completed. In the case of UDP, datagrams are associated with an <strong>ESTABLISHED</strong> state, once the connection tuple <strong>(src, dst, sport, dport)</strong> is reversed.</p>
<p>The <strong>RELATED</strong> state is a bit more complicated. The state of a connection is <strong>RELATED</strong>, when there is a direct relation between a previous connection and the current one. The following example described such a situation:</p>
<p><img src="icmp-type-3.png" alt="ICMP response is RELATED to UDP datagram"></p>
<p>A UDP datagram with arbitrary content is sent to port 222 of a server that doesn't have any service listing on that port and does not filter it either. Due to the closed port, the server is rejecting the packet with an ICMP packet of type 3 (&ldquo;Destination unreachable&rdquo;) and code 3 (&ldquo;Port unreachable&rdquo;). Although the ICMP error is sent as a response to the UDP datagram, it is a dedicated connection. Since ICMP error messages are common responses they are considered <strong>RELATED</strong> to the previous connection.</p>
<p>Besides ICMP there are a few protocols like FTP, SIP or H.323 that could initiate new connections in response to existing ones. FTP is a well known example, that could initiate a dedicated connection to the ftp-data port 20, after requesting a file to download on port 21 (or whatever port the service is running on). Data connections from a FTP server could again be treated as <strong>RELATED</strong> to the original communication.</p>
<p>In order to examine specific protocols, netfilter contains some helper modules like nf_conntrack_ftp.ko, nf_conntrack_sip.ko, which when loaded, parse matching packets and set an <strong>expect</strong> flag, if specific sequences (like the <strong>PORT</strong> command for FTP) are discovered.</p>
<p>Conntrack helper modules pose a certain security risk, because they could inadvertently open other ports than the indended ones if not used correctly. [<a href="https://home.regit.org/netfilter-en/secure-use-of-helpers/">1</a>]</p>
<p>In early kernel versions automatic helper assignment was enabled by default and it was not possible to disable this behaviour.</p>
<p>For this purpose, Linux 3.5 introduced the following sysctl variable:</p>
<p><code>net.netfilter.nf_conntrack_helper</code></p>
<p>The default value for this sysctl was &ldquo;1&rdquo; until Linux 4,7, when the default changed to &ldquo;0&rdquo;. [<a href="https://github.com/torvalds/linux/commit/486dcf43da7815baa615822f3e46883ccca5400f">2</a>]</p>
<p><code>-m conntrack --ctstate INVALID -j ufw-logging-deny</code>
<code>-m conntrack --ctstate INVALID -j DROP</code></p>
<p>These two rules track packets associated with an <strong>INVALID</strong> connection state. These packets, or more precisely their connection state, is neither <strong>NEW</strong>, nor <strong>ESTABLISHED</strong> or <strong>RELATED</strong>. First, packets are sent to the  <strong>ufw-logging-deny</strong> target, which consists of the following rules:</p>
<p><code>-m conntrack --ctstate INVALID -m limit --limit 3/min --limit-burst 10 -j RETURN</code></p>
<p><code>-m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;</code></p>
<p>These two rules basically deal as a rate-limiting mechanism. Unless the rate of INVALID connections exceeds 3 connections per minute, packets are directly sent back to the previous chain. Otherwise packets are logged to syslog, with a prefix of <strong>&quot;[UFW BLOCK] &ldquo;</strong>.</p>
<p>The second rule then drops packets belonging to an <strong>INVALID</strong> connection state.</p>
<h4 id="icmp">ICMP</h4>
<p><code>-A ufw-before-input -p icmp -m icmp --icmp-type 3 -j ACCEPT</code></p>
<p><code>-A ufw-before-input -p icmp -m icmp --icmp-type 11 -j ACCEPT</code></p>
<p><code>-A ufw-before-input -p icmp -m icmp --icmp-type 12 -j ACCEPT</code></p>
<p><code>-A ufw-before-input -p icmp -m icmp --icmp-type 8 -j ACCEPT</code></p>
<p>These 4 rules deal with incoming ICMP messages and allow the following ICMP types:</p>
<ul>
<li>Type 3: <strong>Destination unreachable</strong></li>
<li>Type 11: <strong>Time exceeded</strong></li>
<li>Type 12: <strong>Parameter problem</strong></li>
<li>Type 8: <strong>Echo</strong></li>
</ul>
<h4 id="dhcp">DHCP</h4>
<p><code>-A ufw-before-input -p udp -m udp --sport 67 --dport 68 -j ACCEPT</code></p>
<p>The rule above allows incoming UDP datagrams to port 68 (DHCP client), if they originate from UDP port 67 (DHCP server).</p>
<h4 id="local-and-notlocal-packets">Local and not-local packets</h4>
<p><code>-A ufw-before-input -j ufw-not-local</code></p>
<p>The next line that is shown above first transfers all packets to the <strong>ufw-not-local</strong> chain, that is shown below:</p>
<p><code>-A ufw-not-local -m addrtype --dst-type LOCAL -j RETURN</code></p>
<p><code>-A ufw-not-local -m addrtype --dst-type MULTICAST -j RETURN</code></p>
<p><code>-A ufw-not-local -m addrtype --dst-type BROADCAST -j RETURN</code></p>
<p><code>-A ufw-not-local -m limit --limit 3/min --limit-burst 10 -j ufw-logging-deny</code></p>
<p><code>-A ufw-not-local -j DROP</code></p>
<p>The first three rules above check incoming packets for their address type. The <strong>LOCAL</strong> address type does NOT correspond to localnet/localhost but refers to all addresses that are assigned to the host. Directed traffic that originates from other hosts will most likely match this address type.</p>
<p>The <strong>MULTICAST</strong> and <strong>BROADCAST</strong> address types correspond to traffic sent to the special purpose multicast and broadcast addresses.</p>
<p>Packets that matches these three address types are returned to the previous chain. The remaining packets are first logged (if the rate exceeds 3 packets/min) and then discarded in the fifth rule.</p>
<h4 id="mdns">mDNS</h4>
<p><code>-A ufw-before-input -d 224.0.0.251/32 -p udp -m udp --dport 5353 -j ACCEPT</code></p>
<p>This rule accepts all incoming datagrams that are sent to the MDNS multicast address 224.0.0.251 with destination port 5353/UDP.</p>
<h4 id="upnpssdp">UPnP/SSDP</h4>
<p><code>-A ufw-before-input -d 239.255.255.250/32 -p udp -m udp --dport 1900 -j ACCEPT</code></p>
<p>This rule accepts all incoming datagrams that are sent to the SSDP multicast address 239.255.255.250 with destination port 1900/UDP.</p>
<h4 id="used-defined-rules">Used defined rules</h4>
<p>What we have seen so far is a set of default rules that are always there - even if users haven't configured a single custom rule with ufw. Packets that were not previously discarded or accepted by the kernel are now entering the netfilter chain that user could influence with the ufw command line tool:</p>
<p><code>-A ufw-before-input -j ufw-user-input</code></p>
<p>When ufw is first initialized, this chain is empty. This means that even if users decide to configure deny rules for mDNS or SSDP traffic via ufw CLI, these datagrams were most likely be accepted in the previous chains. For more information on this, check section <em>&ldquo;Fingerprinting systems that use UFW&rdquo;</em>.</p>
<p>In order to add an allow rule via ufw, users could for example enter the following command:</p>
<p><code>ufw allow 22</code></p>
<p>If we take a look again at the <strong>ufw-user-input</strong> chain, the following entries appeared:</p>
<p><code>-A ufw-user-input -p tcp -m tcp --dport 22 -j ACCEPT</code></p>
<p><code>-A ufw-user-input -p udp -m udp --dport 22 -j ACCEPT</code></p>
<p>Because no transport protocol was specified in the command, rules were added for both, TCP and UDP.</p>
<p>To only allow a specific protocol it could be appended to the port number:</p>
<p><code>ufw allow 22/tcp</code></p>
<h3 id="ufwafterinput">ufw-after-input</h3>
<p>After user specified rules were processed the remaining packets are sent to the <strong>ufw-after-input</strong> chain.</p>
<p><code>-A ufw-after-input -p udp -m udp --dport 137 -j ufw-skip-to-policy-input</code></p>
<p><code>-A ufw-after-input -p udp -m udp --dport 138 -j ufw-skip-to-policy-input</code></p>
<p><code>-A ufw-after-input -p tcp -m tcp --dport 139 -j ufw-skip-to-policy-input</code></p>
<p><code>-A ufw-after-input -p tcp -m tcp --dport 445 -j ufw-skip-to-policy-input</code></p>
<p><code>-A ufw-after-input -p udp -m udp --dport 67 -j ufw-skip-to-policy-input</code></p>
<p><code>-A ufw-after-input -p udp -m udp --dport 68 -j ufw-skip-to-policy-input</code></p>
<p><code>-A ufw-after-input -m addrtype --dst-type BROADCAST -j ufw-skip-to-policy-input</code></p>
<p>These rules match TCP packets, with destination ports 139 and 445, UDP datagrams with destination ports 137,138, 67 and 68 and traffic with address type <strong>BROADCAST</strong> and moves them to the <strong>ufw-skip-to-policy-input</strong> chain, which in this (default) scenario comprises only one rule:</p>
<p><code>-j DROP</code></p>
<p>If the default policy for INPUT would be changed to ACCEPT, this rule would change to <code>-j ACCEPT</code> as well.</p>
<p>This is an interesting set of rules as the 6th rule would effectively block UDP datagrams with destination port 68, although they were already accepted in <strong>ufw-before-input</strong> and thus never reach this rule.</p>
<h3 id="ufwafterlogginginput">ufw-after-logging-input</h3>
<p>Packets or datagrams that were neither accepted nor dropped/rejected so far are now traversing the <strong>ufw-after-logging-input</strong> chain that containins the following rule:</p>
<p><code>-m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;</code></p>
<p>We've seen a rule like this before and it simply logs everything that exceeds the limit of 3 packets per minute.</p>
<h3 id="ufwrejectinput--ufwtrackinput">ufw-reject-input &amp; ufw-track-input</h3>
<p>Traffic is then handed to the chains <strong>ufw-reject-input</strong> and <strong>ufw-track-input</strong> which however are both empty.</p>
<p>All remaining packets are now dropped, according to the default DROP rule.</p>
<h2 id="output-handling-ipv4">Output handling (IPv4)</h2>
<p>Packets and datagrams that are going to be sent out are traversing the builtin OUTPUT chain. Like the INPUT chain it is populated by ufw with some custom ufw chains as shown below:</p>
<p><img src="ufw-output.png" alt="Default ufw rules for outgoing IPv4 packets"></p>
<p>As opposed to the <strong>INPUT</strong> chain, the default policy of the <strong>OUTPUT</strong> chain is <strong>ACCEPT</strong>.</p>
<h3 id="ufwbeforeloggingoutput">ufw-before-logging-output</h3>
<p>After entering the <strong>INPUT</strong> chain, traffic is moved to the <strong>ufw-before-logging-output</strong> chain that does not contain any entries.</p>
<h3 id="ufwbeforeoutput">ufw-before-output</h3>
<p>Afterwards the <strong>ufw-before-output</strong> chain is traversed including the following rules:</p>
<p><code>-o lo -j ACCEPT</code></p>
<p><code>-m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code></p>
<p><code>-j ufw-user-output</code></p>
<p>The first two look familiar and accept packets destined to the <strong>lo</strong> interface and connections that are either in the <strong>ESTABLISHED</strong> or <strong>RELATED</strong> state.</p>
<p>Afterwards the <strong>ufw-user-output</strong> chain is entered, that is empty by default. User-generated rules that are created with the ufw CLI are written to this chain and processed accordingly.</p>
<h3 id="ufwafteroutput--ufwafterloggingoutput--ufwrejectoutput">ufw-after-output &amp; ufw-after-logging-output &amp; ufw-reject-output</h3>
<p>Afterwards the remaining packets are passing the <strong>ufw-after-output</strong>, <strong>ufw-after-logging-output</strong> and <strong>ufw-reject-output</strong> chains that are all empty.</p>
<h3 id="ufwtrackoutput">ufw-track-output</h3>
<p>The final chain <strong>ufw-track-output</strong> contains the following rules:</p>
<p><code>-p tcp -m conntrack --ctstate NEW -j ACCEPT</code></p>
<p><code>-p udp -m conntrack --ctstate NEW -j ACCEPT</code></p>
<p>These rules accept <strong>NEW</strong> TCP and UDP connections. While TCP-SYN packets or initial UDP datagrams count as <strong>NEW</strong>, there are scenarios where also <strong>TCP-ACK</strong> packets could be regarded as <strong>NEW</strong>. This behaviour is described in section <em>&ldquo;Handling of NEW connections&rdquo;</em>.</p>
<p>All remaining packets are accepted by default, as per the default policy.</p>
<p>It can be concluded that all outgoing packets are allowed by default.</p>
<h2 id="forward-handling-ipv4">Forward handling (IPv4)</h2>
<p>If the system running ufw is not the destination or origin of network traffic, packets are likely forwarded and therefore traversing the builtin <strong>FORWARD</strong> chain.</p>
<p>An overview of the default configuration by ufw is shown below:</p>
<p><img src="ufw-forward.png" alt="Default ufw rules for forwarded IPv4 packets"></p>
<p>The default policy for the <strong>FORWARD</strong> chain is DROP.</p>
<h3 id="ufwbeforeloggingforward">ufw-before-logging-forward</h3>
<p>The first custom chain to be entered is <strong>ufw-before-logging-forward</strong> which does not contain
any entries.</p>
<h3 id="ufwbeforeforward">ufw-before-forward</h3>
<p>Next, the <strong>ufw-before-forward</strong> is traversed that contains the following rules:</p>
<p><code>-m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code></p>
<p><code>-p icmp -m icmp --icmp-type 3 -j ACCEPT</code></p>
<p><code>-p icmp -m icmp --icmp-type 11 -j ACCEPT</code></p>
<p><code>-p icmp -m icmp --icmp-type 12 -j ACCEPT</code></p>
<p><code>-p icmp -m icmp --icmp-type 8 -j ACCEPT</code></p>
<p><code>-j ufw-user-forward</code></p>
<p>The first rule accepts packets associated with an <strong>ESTABLISHED</strong> or <strong>RELATED</strong> connection. We've already seen this rule for incoming and outgoing packets.</p>
<p>The next four rules accept ICMP packets with ICMP types 3, 11, 12 and 8. These are the same ICMP types as we've seen in the <strong>INPUT</strong> chain:</p>
<ul>
<li>Type 3: <strong>Destination unreachable</strong></li>
<li>Type 11: <strong>Time exceeded</strong></li>
<li>Type 12: <strong>Parameter problem</strong></li>
<li>Type 8: <strong>Echo</strong></li>
</ul>
<p>Eventually packets are entering the <strong>ufw-user-forward</strong> chain that contains user defined rules and is empty by default.</p>
<h3 id="ufwafterforward">ufw-after-forward</h3>
<p>The next chain that is traversed is <strong>ufw-after-forward</strong> and in the default configuration is empty.</p>
<h3 id="ufwafterloggingforward">ufw-after-logging-forward</h3>
<p>Within the <strong>ufw-after-logging-forward</strong> chain, a single rule exists:</p>
<p><code>-m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;</code></p>
<p>This rule looks familiar and is logging all packets that exceed a rate of 3/min to syslog.</p>
<h3 id="ufwrejectforward--ufwtrackforward">ufw-reject-forward &amp; ufw-track-forward</h3>
<p>The next chains <strong>ufw-reject-forward</strong> and <strong>ufw-track-forward</strong> are both empty.</p>
<p>At this stage, all remaining packets are discarded, due to the default <strong>DENY</strong> policy.</p>
<h2 id="default-rule-set-ipv6">Default rule set (IPv6)</h2>
<p>When enabling ufw, not only IPv4 rules are generated but also a large set of IPv6 related rules, than can be queried using ip6tables:</p>
<pre><code>-P INPUT DROP
-P FORWARD DROP
-P OUTPUT ACCEPT
-N ufw6-after-forward
-N ufw6-after-input
-N ufw6-after-logging-forward
-N ufw6-after-logging-input
-N ufw6-after-logging-output
-N ufw6-after-output
-N ufw6-before-forward
-N ufw6-before-input
-N ufw6-before-logging-forward
-N ufw6-before-logging-input
-N ufw6-before-logging-output
-N ufw6-before-output
-N ufw6-logging-allow
-N ufw6-logging-deny
-N ufw6-reject-forward
-N ufw6-reject-input
-N ufw6-reject-output
-N ufw6-skip-to-policy-forward
-N ufw6-skip-to-policy-input
-N ufw6-skip-to-policy-output
-N ufw6-track-forward
-N ufw6-track-input
-N ufw6-track-output
-N ufw6-user-forward
-N ufw6-user-input
-N ufw6-user-limit
-N ufw6-user-limit-accept
-N ufw6-user-logging-forward
-N ufw6-user-logging-input
-N ufw6-user-logging-output
-N ufw6-user-output
-A INPUT -j ufw6-before-logging-input
-A INPUT -j ufw6-before-input
-A INPUT -j ufw6-after-input
-A INPUT -j ufw6-after-logging-input
-A INPUT -j ufw6-reject-input
-A INPUT -j ufw6-track-input
-A FORWARD -j ufw6-before-logging-forward
-A FORWARD -j ufw6-before-forward
-A FORWARD -j ufw6-after-forward
-A FORWARD -j ufw6-after-logging-forward
-A FORWARD -j ufw6-reject-forward
-A FORWARD -j ufw6-track-forward
-A OUTPUT -j ufw6-before-logging-output
-A OUTPUT -j ufw6-before-output
-A OUTPUT -j ufw6-after-output
-A OUTPUT -j ufw6-after-logging-output
-A OUTPUT -j ufw6-reject-output
-A OUTPUT -j ufw6-track-output
-A ufw6-after-input -p udp -m udp --dport 137 -j ufw6-skip-to-policy-input
-A ufw6-after-input -p udp -m udp --dport 138 -j ufw6-skip-to-policy-input
-A ufw6-after-input -p tcp -m tcp --dport 139 -j ufw6-skip-to-policy-input
-A ufw6-after-input -p tcp -m tcp --dport 445 -j ufw6-skip-to-policy-input
-A ufw6-after-input -p udp -m udp --dport 546 -j ufw6-skip-to-policy-input
-A ufw6-after-input -p udp -m udp --dport 547 -j ufw6-skip-to-policy-input
-A ufw6-after-logging-forward -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;
-A ufw6-after-logging-input -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;
-A ufw6-before-forward -m rt --rt-type 0 -j DROP
-A ufw6-before-forward -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A ufw6-before-forward -p ipv6-icmp -m icmp6 --icmpv6-type 1 -j ACCEPT
-A ufw6-before-forward -p ipv6-icmp -m icmp6 --icmpv6-type 2 -j ACCEPT
-A ufw6-before-forward -p ipv6-icmp -m icmp6 --icmpv6-type 3 -j ACCEPT
-A ufw6-before-forward -p ipv6-icmp -m icmp6 --icmpv6-type 4 -j ACCEPT
-A ufw6-before-forward -p ipv6-icmp -m icmp6 --icmpv6-type 128 -j ACCEPT
-A ufw6-before-forward -p ipv6-icmp -m icmp6 --icmpv6-type 129 -j ACCEPT
-A ufw6-before-forward -j ufw6-user-forward
-A ufw6-before-input -i lo -j ACCEPT
-A ufw6-before-input -m rt --rt-type 0 -j DROP
-A ufw6-before-input -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 129 -j ACCEPT
-A ufw6-before-input -m conntrack --ctstate INVALID -j ufw6-logging-deny
-A ufw6-before-input -m conntrack --ctstate INVALID -j DROP
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 1 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 2 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 3 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 4 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 128 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 133 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 134 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 135 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 136 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 141 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 142 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 130 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 131 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 132 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 143 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 148 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 149 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 151 -m hl --hl-eq 1 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 152 -m hl --hl-eq 1 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 153 -m hl --hl-eq 1 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 144 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 145 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 146 -j ACCEPT
-A ufw6-before-input -p ipv6-icmp -m icmp6 --icmpv6-type 147 -j ACCEPT
-A ufw6-before-input -s fe80::/10 -d fe80::/10 -p udp -m udp --sport 547 --dport 546 -j ACCEPT
-A ufw6-before-input -d ff02::fb/128 -p udp -m udp --dport 5353 -j ACCEPT
-A ufw6-before-input -d ff02::f/128 -p udp -m udp --dport 1900 -j ACCEPT
-A ufw6-before-input -j ufw6-user-input
-A ufw6-before-output -o lo -j ACCEPT
-A ufw6-before-output -m rt --rt-type 0 -j DROP
-A ufw6-before-output -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 1 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 2 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 3 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 4 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 128 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 129 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 133 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 136 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 135 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 134 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 141 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 142 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 130 -j ACCEPT
-A ufw6-before-output -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 131 -j ACCEPT
-A ufw6-before-output -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 132 -j ACCEPT
-A ufw6-before-output -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 143 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 148 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -p ipv6-icmp -m icmp6 --icmpv6-type 149 -m hl --hl-eq 255 -j ACCEPT
-A ufw6-before-output -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 151 -m hl --hl-eq 1 -j ACCEPT
-A ufw6-before-output -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 152 -m hl --hl-eq 1 -j ACCEPT
-A ufw6-before-output -s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 153 -m hl --hl-eq 1 -j ACCEPT
-A ufw6-before-output -j ufw6-user-output
-A ufw6-logging-allow -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW ALLOW] &quot;
-A ufw6-logging-deny -m conntrack --ctstate INVALID -m limit --limit 3/min --limit-burst 10 -j RETURN
-A ufw6-logging-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;
-A ufw6-skip-to-policy-forward -j DROP
-A ufw6-skip-to-policy-input -j DROP
-A ufw6-skip-to-policy-output -j ACCEPT
-A ufw6-track-output -p tcp -m conntrack --ctstate NEW -j ACCEPT
-A ufw6-track-output -p udp -m conntrack --ctstate NEW -j ACCEPT
-A ufw6-user-limit -m limit --limit 3/min -j LOG --log-prefix &quot;[UFW LIMIT BLOCK] &quot;
</code></pre><h2 id="input-handling-ipv6">Input handling (IPv6)</h2>
<p>The builtin <strong>INPUT</strong> chain is populated with a set of rules that are shown in the following illustration:</p>
<p><img src="ufw-input-ipv6.png" alt="Default ufw rules for incoming IPv4 packets"></p>
<p>Like in the IPv4 examples, the ip6tables <strong>INPUT</strong> chain also has a default policy set to <strong>DROP</strong>.</p>
<h3 id="ufw6beforelogginginput">ufw6-before-logging-input</h3>
<p>The first chain <strong>ufw6-before-logging-input</strong> is empty.</p>
<h3 id="ufw6beforeinput">ufw6-before-input</h3>
<p>Next, the chain <strong>ufw6-before-input</strong> is entered that has a large set of pre-configured rules. These will be described step by step:</p>
<p><code>-i lo -j ACCEPT</code>
<code>-m rt --rt-type 0 -j DROP</code></p>
<p>The first rule accepts traffic destined to the <strong>lo</strong> interface. This allows local communication between applications, when packet-based sockets are used.</p>
<p>The second rule matches if a IPv6 routing header is found. A certain routing type (Type 0: <strong>Source Routing</strong>) exists that was deprecated as per RFC-5095, due to its security risks. [<a href="https://www.ietf.org/rfc/rfc5095.txt">3</a>]
This header is comparable to source routing option in IPv4 that could be used to partly or completely control the route that packets take through networks. Firewall evasions were way easier when source routing was still allowed.</p>
<p><code>-m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code>
<code>-m conntrack --ctstate INVALID -j ufw6-logging-deny</code>
<code>-m conntrack --ctstate INVALID -j DROP</code></p>
<p>The three rules above check the state of the connection, like in many previous examples. If the connection is either in a <strong>RELATED</strong> or <strong>ESTABLISHED</strong> state, the packets are accepted.</p>
<p>Connections that are <strong>INVALID</strong> are dropped, but before that, they are sent to the <strong>ufw6-logging-deny</strong> chain, that contains the following rules:</p>
<p><code>-m conntrack --ctstate INVALID -m limit --limit 3/min --limit-burst 10 -j RETURN</code>
<code>-m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;</code></p>
<p>THe mechanism is identical to the IPv4 counterpart: Packets associated with an <strong>INVALID</strong> connection are sent back to the previous chain, unless the rate exceeds 3 packets per minute. Packets that hit the threshold are logged to syslog and leave the chain afterwards.</p>
<p>Most of the following rules deal with ICMPv6 traffic. In order to provide a sufficient overview, some relevant ICMPv6 types are introduced:</p>
<ul>
<li>Type 1: <strong>Destination unreachable</strong></li>
<li>Type 2: <strong>Packet Too Big</strong></li>
<li>Type 3: <strong>Time Exceeded</strong></li>
<li>Type 4: <strong>Parameter Problem</strong></li>
<li>Type 128: <strong>Echo Request</strong></li>
<li>Type 129: <strong>Echo Reply</strong></li>
<li>Type 130: <strong>Multicast Listener Query</strong></li>
<li>Type 131: <strong>Multicast Listener Report</strong></li>
<li>Type 132: <strong>Multicast Listener Done</strong></li>
<li>Type 133: <strong>Router Solicitation</strong></li>
<li>Type 134: <strong>Router Advertisement</strong></li>
<li>Type 135: <strong>Neighbor Solicitation</strong></li>
<li>Type 136: <strong>Neighbor Advertisement</strong></li>
<li>Type 141: <strong>Inverse Neighbor Discovery</strong></li>
<li>Type 142: <strong>Inverse Neighbor Discovery</strong></li>
<li>Type 143: <strong>Version 2 Multicast Listener Report</strong></li>
<li>Type 144: <strong>Home Agent Address Discovery Request Message</strong></li>
<li>Type 145: <strong>Home Agent Address Discovery Reply Message</strong></li>
<li>Type 146: <strong>Mobile Prefix Solicitation</strong></li>
<li>Type 147: <strong>Mobile Prefix Advertisement</strong></li>
<li>Type 148: <strong>Certification Path Solicitation Message</strong></li>
<li>Type 149: <strong>Certification Path Advertisement Message</strong></li>
<li>Type 151: <strong>Multicast Router Advertisement</strong></li>
<li>Type 152: <strong>Multicast Router Solicitation</strong></li>
<li>Type 153: <strong>Multicast Router Termination</strong></li>
</ul>
<p>Now with this list in mind, let's take a look at some ICMPv6 rules:</p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 129 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 1 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 2 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 3 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 4 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 128 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 144 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 145 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 146 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 147 -j ACCEPT</code></p>
<p>These rules accept ICMPv6 packets, that match the type specified in the rule. While some of the allowed types are used in error handling (<strong>Destination unreachable</strong>, <strong>Time Exceeded</strong>, etc.) there are also types like <strong>Echo Request</strong> and <strong>Echo Reply</strong> that are accepted.</p>
<p>Please note that all these rules are evaluated before the chain with user-defined rules is even traversed.</p>
<p>The next set of rules also deal with ICMPv6, but add some little details:</p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 133 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 134 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 135 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 136 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 141 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 142 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 148 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 149 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p>These rules almost look like the previous ones, however they also contain the option <code>-m hl --hl-eq 255</code> which match the <strong>Hop Limit</strong> field in the IPv6 header, if its value it set to 255.</p>
<p>So what does that value mean? The <strong>Hop Limit</strong> header in IPv6 is what the <strong>TTL</strong> header is in IPv4. It defines the maximum number of hops over which packets can be sent until they are dropped.</p>
<p>Why is it set to 255 for these specific ICMPv6 types? The types in the rules above correspond to <strong>Neighbour Discovery</strong> and <strong>Router Discovery</strong> mechanisms that happen <strong>on the link</strong> (compared to <strong>ARP</strong> in IPv4). A limit of 255 ensures, that off-link packets (which would have a hop limit of &lt; 255) are not allowed. This is specified in RFC-2461 section 3.1. [<a href="https://www.ietf.org/rfc/rfc2461.txt">4</a>]</p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 130 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 131 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 132 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 143 -j ACCEPT</code></p>
<p>The next 4 rules above refer to <strong>Multicast Listener</strong> and <strong>Version 2 Multicast Listener</strong> packets. In these rules an additional source address range of <strong>fe80::/10</strong> was specified. This is the ip range reserved for IPv6 link-local addresses that are only valid on the link, that the host is connected to. These rules ensure that no multicast traffic is accepted that originates from non link-local addresses.</p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 151 -m hl --hl-eq 1 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 152 -m hl --hl-eq 1 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 153 -m hl --hl-eq 1 -j ACCEPT</code></p>
<p>These rules above filter for ICMPv6 types <strong>Multicast Router Advertisement</strong>, <strong>Multicast Router Solicitation</strong> and <strong>Multicast Router Termination</strong>. In addition to that packets are only accepted, if the source address is a link-local address and the hop limit is 1. A hop limit of 1 ensures that packets can't travel beyond the link as described in RFC-2710 section 4. [<a href="https://www.ietf.org/rfc/rfc2710.txt">5</a>]</p>
<p><code>-s fe80::/10 -d fe80::/10 -p udp -m udp --sport 547 --dport 546 -j ACCEPT</code></p>
<p>The set of IPv4 rules for the <strong>INPUT</strong> chain included a rule to allow DHCP traffic. The same applies for IPv6, in the rule shown above.</p>
<p>It accepts packets that originate from link-local addresses and are sent to link-local addresses. Furthermore the protocol has to be UDP, the source port has to be equal to 547 (<strong>DHCPv6 Server</strong>) and the destination port needs to be 546 (<strong>DHCPv6 Client</strong>).</p>
<p><code>-d ff02::fb/128 -p udp -m udp --dport 5353 -j ACCEPT</code></p>
<p>As IPv4 had a rule to allow <strong>mDNS</strong> traffic, the rule above allows the same for <strong>mDNS6</strong>. The packet is accepted, if the destination address is <strong>ff02::fb/128</strong>, which corresponds to the special purpose link-local scope multicast addresses of <strong>mDNS6</strong>.</p>
<p><code>-d ff02::f/128 -p udp -m udp --dport 1900 -j ACCEPT</code></p>
<p><strong>UPnP</strong> is also accepted, if the UDP destination port is 1900 and the destination address is the special purpose link-local scope multicast address <strong>ff02::f/128</strong>.</p>
<p>All remaining packets are sent to the <code>-j ufw6-user-input</code> chain that contains user-defined rules. By default it's empty.</p>
<h3 id="ufw6afterinput">ufw6-after-input</h3>
<p>The next major chain to be traversed is <strong>ufw6-after-input</strong>. This chain contains the following rules:</p>
<p><code>-p udp -m udp --dport 137 -j ufw6-skip-to-policy-input</code></p>
<p><code>-p udp -m udp --dport 138 -j ufw6-skip-to-policy-input</code></p>
<p><code>-p tcp -m tcp --dport 139 -j ufw6-skip-to-policy-input</code></p>
<p><code>-p tcp -m tcp --dport 445 -j ufw6-skip-to-policy-input</code></p>
<p><code>-p udp -m udp --dport 546 -j ufw6-skip-to-policy-input</code></p>
<p><code>-p udp -m udp --dport 547 -j ufw6-skip-to-policy-input</code></p>
<p>This set of rules is very similar to the <strong>ufw-after-input</strong> chain for IPv4. Packets with destination ports for Netbios, SMB and DHCPv6 are sent to the <strong>ufw6-skip-to-policy-input</strong> chain that in the default setting contains a single rule:</p>
<p><code>-j DROP</code></p>
<h3 id="ufw6afterlogginginput">ufw6-after-logging-input</h3>
<p>Packets that made it this far are now entering the <strong>ufw6-after-logging-input</strong> chain, that only contains a rule for logging:</p>
<p><code>-m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;</code></p>
<p>As before, packets that exceed a rate of 3 packets per minute are logged to syslog.</p>
<h3 id="ufw6rejectinput--ufw6trackinput">ufw6-reject-input &amp; ufw6-track-input</h3>
<p>Packets are then sent to the next two empty chains <strong>ufw6-reject-input</strong> and <strong>ufw6-track-input</strong> and are eventually dropped, as per the default <strong>DROP</strong> policy.</p>
<h2 id="output-handling-ipv6">Output handling (IPv6)</h2>
<p>As for IPv4, packets that are about to leave a network interface traverse the builtin OUTPUT chain. It is populated by ufw with the following chains:</p>
<p><img src="ufw-output-ipv6.png" alt="Default ufw rules for outgoing IPv4 packets"></p>
<p>The default policy for the <strong>OUTPUT</strong> chain is set to <strong>ACCEPT</strong>. All packets that are neither dropped nor rejected are accepted by default.</p>
<h3 id="ufw6beforeloggingoutput">ufw6-before-logging-output</h3>
<p>The first chain <strong>ufw6-before-logging-output</strong> does not contain any entries.</p>
<h3 id="ufw6beforeoutput">ufw6-before-output</h3>
<p>Afterwards the <strong>ufw6-before-output</strong> chain is entered, which as opposed to the IPv4 version, contains much more rules:</p>
<p><code>-o lo -j ACCEPT</code></p>
<p><code>-m rt --rt-type 0 -j DROP</code></p>
<p><code>-m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code></p>
<p>The first rule again ensures that local communication using the <strong>lo</strong> interface is possible.</p>
<p><strong>Source routing</strong> is also denied for packets leaving the host, so all packets that match the <strong>rt-type 0</strong> are dropped instantly.</p>
<p>The third rule accepts all packets that belong to an <strong>ESTABLISHED</strong> or <strong>RELATED</strong> connection.</p>
<p>The next rules deal with many ICMPv6 types that we have already seen in the <strong>INPUT</strong> chain:</p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 1 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 2 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 3 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 4 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 128 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 129 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 133 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 136 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 135 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 134 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 141 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 142 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 130 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 131 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 132 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 143 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 148 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 149 -m hl --hl-eq 255 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 151 -m hl --hl-eq 1 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 152 -m hl --hl-eq 1 -j ACCEPT</code></p>
<p><code>-s fe80::/10 -p ipv6-icmp -m icmp6 --icmpv6-type 153 -m hl --hl-eq 1 -j ACCEPT</code></p>
<p>As this block of rules is more or less a repitition of the <strong>INPUT</strong> version, it is not explained in detail. Please refer to the previous section for further information.</p>
<p>Basically these rules allow ICMPv6 packets of different types. For some it depends on the values of <strong>Hop Limit</strong> and the source address.</p>
<p>Afterwards, packets are sent to the empty <strong>ufw6-user-output</strong> chain.</p>
<h3 id="ufw6afteroutput--ufw6afterloggingoutput--ufw6rejectoutput">ufw6-after-output &amp; ufw6-after-logging-output &amp; ufw6-reject-output</h3>
<p>The next three chains <strong>ufw6-after-output</strong>, <strong>ufw6-after-logging-output</strong> and <strong>ufw6-reject-output</strong> are empty.</p>
<h3 id="ufw6trackoutput">ufw6-track-output</h3>
<p>The final chain <strong>ufw6-track-output</strong> contains the following rules:</p>
<p><code>-p tcp -m conntrack --ctstate NEW -j ACCEPT</code></p>
<p><code>-p udp -m conntrack --ctstate NEW -j ACCEPT</code></p>
<p>These rules accept packets that initiate a <strong>NEW</strong> connection state.</p>
<p>All remaining packets are accepted as per the default policy. This means that only packets with <strong>source routing</strong> header are discarded by default.</p>
<h2 id="forward-handling-ipv6">Forward handling (IPv6)</h2>
<p>Packets that need to be routed to other systems are traversing the builtin <strong>FORWARD</strong> chain.</p>
<p>An overview of the default configuration by ufw is shown below:</p>
<p><img src="ufw-forward-ipv6.png" alt="Default ufw rules for forwarded IPv4 packets"></p>
<p>The default policy for the <strong>FORWARD</strong> chain is DROP.</p>
<h3 id="ufw6beforeloggingforward">ufw6-before-logging-forward</h3>
<p>Packets that are forwarded first enter the <strong>ufw6-before-logging-forward</strong> chain that does not contain any rules.</p>
<h3 id="ufw6beforeforward">ufw6-before-forward</h3>
<p>Afterwards the chain <strong>ufw6-before-forward</strong> is entered. Some rules are pre-configured by ufw:</p>
<p><code>-m rt --rt-type 0 -j DROP</code></p>
<p><code>-m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code></p>
<p>The first rule again drops packets with <strong>source routing</strong> header. The second rule only accepts packets that belong to an <strong>ESTABLISHED</strong> or <strong>RELATED</strong> connection state.</p>
<p>Next, some ICMPv6 rules are evaluated:</p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 1 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 2 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 3 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 4 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 128 -j ACCEPT</code></p>
<p><code>-p ipv6-icmp -m icmp6 --icmpv6-type 129 -j ACCEPT</code></p>
<p>These ICMPv6 types correspond to typical error handling messages and <strong>Echo Request</strong> and <strong>Echo Reply</strong> packets. These are immediately accepted.</p>
<p>Afterwards the empty <strong>-j ufw6-user-forward</strong> chain is entered, that is used for user-defined <strong>FORWARD</strong> rules.</p>
<h3 id="ufw6afterforward">ufw6-after-forward</h3>
<p>The next chain <strong>ufw6-after-forward</strong> does not contain any rules.</p>
<h3 id="ufw6afterloggingforward">ufw6-after-logging-forward</h3>
<p>The only rule present in the <strong>ufw6-after-logging-forward</strong> chain performs logging of packets that exceed the rate of 3 packets per minute.</p>
<p><code>-m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW BLOCK] &quot;</code></p>
<h3 id="ufw6rejectforward--ufw6trackforward">ufw6-reject-forward &amp; ufw6-track-forward</h3>
<p>The remaining two chains <strong>ufw6-reject-forward</strong> and <strong>ufw6-track-forward</strong> are empty.</p>
<p>Packets that were not accepted or dropped so far are now dropped as per the default policy.</p>
<h2 id="fingerprinting-systems-that-use-ufw">Fingerprinting systems that use UFW</h2>
<p>If you are port scanning other hosts, it might be good to know if any packet filtering rules are in place that block port scans.</p>
<p>Systems that run ufw have some interesting characteristics. Since user-defined rules are placed behind many other pre-configured rules, some ports might be open, although a deny rule was added to the user-specified list of rules.</p>
<p>A good example for this is DHCP. To recall how DHCP is handled, let's take a quick look at the rule within the chain <strong>ufw-before-input</strong>:</p>
<p><code>-p udp -m udp --sport 67 --dport 68 -j ACCEPT</code></p>
<p>As this rule allows incoming packets to UDP port 68 if they originate from UDP port 67, it's possible to detect this in a port scan:</p>
<pre><code>$ sudo nmap -vvv -n -Pn -sU -g 67 --top-ports 20 172.17.0.2
Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.
Starting Nmap 7.93SVN ( https://nmap.org ) at 2022-11-30 21:25 CET
Initiating ARP Ping Scan at 21:25
Scanning 172.17.0.2 [1 port]
Completed ARP Ping Scan at 21:25, 0.06s elapsed (1 total hosts)
Initiating UDP Scan at 21:25
Scanning 172.17.0.2 [20 ports]
Completed UDP Scan at 21:26, 1.45s elapsed (20 total ports)
Nmap scan report for 172.17.0.2
Host is up, received arp-response (0.000071s latency).
Scanned at 2022-12-01 21:25:59 CET for 2s

PORT      STATE         SERVICE      REASON
53/udp    open|filtered domain       no-response
67/udp    open|filtered dhcps        no-response
68/udp    closed        dhcpc        port-unreach ttl 64
69/udp    open|filtered tftp         no-response
123/udp   open|filtered ntp          no-response
135/udp   open|filtered msrpc        no-response
137/udp   open|filtered netbios-ns   no-response
138/udp   open|filtered netbios-dgm  no-response
139/udp   open|filtered netbios-ssn  no-response
161/udp   open|filtered snmp         no-response
162/udp   open|filtered snmptrap     no-response
445/udp   open|filtered microsoft-ds no-response
500/udp   open|filtered isakmp       no-response
514/udp   open|filtered syslog       no-response
520/udp   open|filtered route        no-response
631/udp   open|filtered ipp          no-response
1434/udp  open|filtered ms-sql-m     no-response
1900/udp  open|filtered upnp         no-response
4500/udp  open|filtered nat-t-ike    no-response
49152/udp open|filtered unknown      no-response
MAC Address: 02:42:AC:11:00:02 (Unknown)

Read data files from: /usr/local/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 1.65 seconds
           Raw packets sent: 54 (4.484KB) | Rcvd: 2 (84B)
</code></pre><p>The results of a top 20 UDP port scan show that all ports, except port 68 are shown as <strong>open|filtered</strong>. This makes sense, since the default <strong>INPUT</strong> policy is <strong>DROP</strong>. The parameter <code>-g 67</code> was chosen to set the source port to 67, as per the <strong>ACCEPT</strong> rule in the pre-configured chain. The results show that port 68 is <strong>closed</strong> and an ICMP message of type <strong>Port Unreachable</strong> was sent back.</p>
<p>So, what would happen if users decide to block UDP port 68 by using the ufw cli? Let's try:</p>
<pre><code>$ sudo ufw deny 68/udp
Rule added
Rule added (v6)
</code></pre><p>The command above added a deny rule for UDP port 68. Another scan is started:</p>
<pre><code>$ sudo nmap -vvv -n -Pn -sU -g 67 -p 68 172.17.0.2
Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.
Starting Nmap 7.93SVN ( https://nmap.org ) at 2022-11-30 21:33 CET
Initiating ARP Ping Scan at 21:33
Scanning 172.17.0.2 [1 port]
Completed ARP Ping Scan at 21:33, 0.05s elapsed (1 total hosts)
Initiating UDP Scan at 21:33
Scanning 172.17.0.2 [1 port]
Completed UDP Scan at 21:33, 0.06s elapsed (1 total ports)
Nmap scan report for 172.17.0.2
Host is up, received arp-response (0.000025s latency).
Scanned at 2022-12-01 21:33:34 CET for 0s

PORT   STATE  SERVICE REASON
68/udp closed dhcpc   port-unreach ttl 64
MAC Address: 02:42:AC:11:00:02 (Unknown)

Read data files from: /usr/local/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 0.20 seconds
           Raw packets sent: 2 (56B) | Rcvd: 2 (84B)
</code></pre><p>The port still shows up as <strong>closed</strong>. The relevant iptables rules confirm why that happens:</p>
<pre><code>Chain ufw-before-input (1 references)
target     prot opt source               destination         
[...]
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            udp spt:67 dpt:68
[...]
ufw-user-input  all  --  0.0.0.0/0            0.0.0.0/0           

Chain ufw-user-input (1 references)
target     prot opt source               destination         
DROP       udp  --  0.0.0.0/0            0.0.0.0/0            udp dpt:68
</code></pre><p>The <strong>ACCEPT</strong> rule is evaluated before the <strong>ufw-user-input</strong> chain with the <strong>DROP</strong> rule is called.</p>
<p>In order to block port 68/UDP, users would need to manually adjust <strong>/etc/ufw/before.rules</strong> or <strong>/etc/ufw/before6.rules</strong>.</p>
<p>This means that scanning UDP port 68 with source port of 67 is a good way to detect ufw. Please note that other firewalls might also allow port 68 by default, so it shouldn't be taken for granted.</p>
<p>The <strong>ufw-before-input</strong> chain also accepts certain ICMP types, for example type 8 <strong>Echo Request</strong>. ICMP type 13 <strong>Timestamp Request</strong> and ICMP type 17 <strong>Address Mask Request</strong> are not allowed and therefore dropped by the default policy. Let's validate that with 3 consecutive scans using ICMP types 8, 13 and 17:</p>
<pre><code>$ sudo nmap -vvv -n -sn -PE --send-ip 172.17.0.2
Starting Nmap 7.93SVN ( https://nmap.org ) at 2022-11-30 21:53 CET
Initiating Ping Scan at 21:53
Scanning 172.17.0.2 [1 port]
Completed Ping Scan at 21:53, 0.03s elapsed (1 total hosts)
Nmap scan report for 172.17.0.2
Host is up, received echo-reply ttl 64 (0.00015s latency).
MAC Address: 02:42:AC:11:00:02 (Unknown)
Read data files from: /usr/local/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 0.15 seconds
           Raw packets sent: 1 (28B) | Rcvd: 1 (28B)
</code></pre><pre><code>$ sudo nmap -vvv -n -sn -PP --send-ip 172.17.0.2
Starting Nmap 7.93SVN ( https://nmap.org ) at 2022-11-30 21:53 CET
Initiating Ping Scan at 21:53
Scanning 172.17.0.2 [1 port]
Completed Ping Scan at 21:54, 2.02s elapsed (1 total hosts)
Nmap scan report for 172.17.0.2 [host down, received no-response]
Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn
Nmap done: 1 IP address (0 hosts up) scanned in 2.06 seconds
           Raw packets sent: 2 (80B) | Rcvd: 0 (0B)
</code></pre><pre><code>$ sudo nmap -vvv -n -sn -PM --send-ip 172.17.0.2
Starting Nmap 7.93SVN ( https://nmap.org ) at 2022-11-30 21:54 CET
Initiating Ping Scan at 21:54
Scanning 172.17.0.2 [1 port]
Completed Ping Scan at 21:54, 2.03s elapsed (1 total hosts)
Nmap scan report for 172.17.0.2 [host down, received no-response]
Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn
Nmap done: 1 IP address (0 hosts up) scanned in 2.08 seconds
           Raw packets sent: 2 (64B) | Rcvd: 0 (0B)
</code></pre><p>The only response is shown in the first scan in which ICMP type 8 was used. In combination with the DHCP scan, this is another good candidate to detect ufw.</p>
<p>The IPv6 ruleset also contained a large number of ICMPv6 related rules, of which two allow the ICMPv6 types <strong>Echo Request</strong> and <strong>Neighbor Solicitation</strong>.</p>
<p>A <strong>Neighbor Solicitation</strong> request could be sent using <strong>ndisc6</strong>:</p>
<pre><code>$ ndisc6 fe80::42:acff:fe11:2 eth0
Soliciting fe80::42:acff:fe11:2 (fe80::42:acff:fe11:2) on eth0...
Target link-layer address: 02:42:AC:11:00:02
 from fe80::42:acff:fe11:2
</code></pre><p>The command above shows that a response was received, which means that incoming ICMPv6 type 135 packets were allowed.</p>
<p><strong>Echo Request</strong> (ICMPv6 type 128) packets could be sent using <strong>ping6</strong>:</p>
<pre><code>$ ping6 -c 1 fe80::42:acff:fe11:2%eth0
PING fe80::42:acff:fe11:2%eth0(fe80::42:acff:fe11:2%eth0) 56 data bytes
64 bytes from fe80::42:acff:fe11:2%eth0: icmp_seq=1 ttl=64 time=0.172 ms

--- fe80::42:acff:fe11:2%eth0 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.172/0.172/0.172/0.000 ms
</code></pre><p>After submitting this request the host answered successfully.</p>
<p>These two checks above are not very meaningful, as these allow rules could be configured in any firewall. Also we would observe the same behaviour if there aren't any firewalls in place or if all traffic is allowed.</p>
<p>Therefore, for accurate finterprinting it is recommended to cross-check as much of the default allow and deny rules (explicit and implicit rules).</p>
<p>A rule that is more suitable for this purpose is the following, covering DHCPv6:</p>
<p><code>-A ufw6-before-input -s fe80::/10 -d fe80::/10 -p udp -m udp --sport 547 --dport 546 -j ACCEPT</code></p>
<p>As this rule only accepts link-local UDP datagrams that arrive on port 546 and originate from port 547, this is a good test case for nmap:</p>
<pre><code>root@a35d59e6e8d7:~# nmap -vvv -n -Pn -sU -6 -e eth0 -g 547 -p 546 fe80::42:acff:fe11:2
Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-30 21:56 UTC
Initiating ND Ping Scan at 21:56
Scanning fe80::42:acff:fe11:2 [1 port]
Completed ND Ping Scan at 15:56, 0.03s elapsed (1 total hosts)
Initiating UDP Scan at 21:56
Scanning fe80::42:acff:fe11:2 [1 port]
Completed UDP Scan at 21:56, 0.02s elapsed (1 total ports)
Nmap scan report for fe80::42:acff:fe11:2
Host is up, received nd-response (0.000069s latency).
Scanned at 2022-12-01 21:56:26 UTC for 0s

PORT    STATE  SERVICE       REASON
546/udp closed dhcpv6-client port-unreach ttl 64
MAC Address: 02:42:AC:11:00:02 (Unknown)

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 0.25 seconds
           Raw packets sent: 2 (120B) | Rcvd: 2 (168B)
</code></pre><p>The scan results above show that the port is closed (not filtered) because the rule matched.</p>
<p>Let's try the same scan, but without specifying the source port:</p>
<pre><code>root@a35d59e6e8d7:~# nmap -vvv -n -Pn -sU -6 -e eth0 -p 546 fe80::42:acff:fe11:2
Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-30 21:56 UTC
Initiating ND Ping Scan at 21:56
Scanning fe80::42:acff:fe11:2 [1 port]
Completed ND Ping Scan at 21:56, 0.03s elapsed (1 total hosts)
Initiating UDP Scan at 21:56
Scanning fe80::42:acff:fe11:2 [1 port]
Completed UDP Scan at 21:56, 0.02s elapsed (1 total ports)
Nmap scan report for fe80::42:acff:fe11:2
Host is up, received nd-response (0.000069s latency).
Scanned at 2022-12-01 21:56:26 UTC for 0s

PORT    STATE         SERVICE       REASON
546/udp open|filtered dhcpv6-client no-response
MAC Address: 02:42:AC:11:00:02 (Unknown)

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 0.65 seconds
           Raw packets sent: 2 (120B) | Rcvd: 2 (168B)
</code></pre><p>This time the port shows up as <strong>open|filtered</strong> because the allow rule does not match and the default policy dropped the datagram.</p>
<p>There is another interesting behaviour with the default ufw rules and default Debian or Ubuntu kernel settings. So far we have seen many rules that allow packets belonging to <strong>ESTABLISHED</strong> or <strong>RELATED</strong> connections. If new connections are created, the conntrack state is <strong>NEW</strong> - but what exactly can be considered <strong>NEW</strong>?</p>
<p>For sure incoming TCP-SYN packets are the best example for attempts to create a new connection. For UDP usually the first datagram can be referred to as <strong>NEW</strong>. But that's not it. Let's take a look at the sysctl parameter <code>nf_conntrack_tcp_loose</code> and its documentation [<a href="https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt">6</a>]:</p>
<pre><code>nf_conntrack_tcp_loose - BOOLEAN
	0 - disabled
	not 0 - enabled (default)

	If it is set to zero, we disable picking up already established
	connections.
</code></pre><p>This variable defines how strict connections are handled by conntrack. On default Debian or Ubuntu installations this variable is set to 1, which means that &ldquo;<em>picking up already established connections</em>&rdquo; is enabled.</p>
<p>In fact TCP packets carrying the <strong>ACK</strong> flag are also considered <strong>NEW</strong>, if this variable is set to 1. Consequently, if arbitrary ACKs are allowed, <strong>ACK-scans</strong> are allowed as well.</p>
<p>Let's try this by first adding an allow rule for port 22/TCP:</p>
<pre><code>root@9ad217af69b6:~# ufw allow 22/tcp
Rule added
Rule added (v6)
</code></pre><p>Now with the new user-defined rule in place, let's run an <strong>ACK-scan</strong>:</p>
<pre><code>root@a35d59e6e8d7:~# nmap -vvv -n -Pn -sA -p 22 172.17.0.2
Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-30 21:58 UTC
Initiating ARP Ping Scan at 21:58
Scanning 172.17.0.2 [1 port]
Completed ARP Ping Scan at 21:58, 0.02s elapsed (1 total hosts)
Initiating ACK Scan at 21:58
Scanning 172.17.0.2 [1 port]
Completed ACK Scan at 21:58, 0.02s elapsed (1 total ports)
Nmap scan report for 172.17.0.2
Host is up, received arp-response (0.000044s latency).
Scanned at 2022-11-30 21:58:42 UTC for 0s

PORT   STATE      SERVICE REASON
22/tcp unfiltered ssh     reset ttl 64
MAC Address: 02:42:AC:11:00:02 (Unknown)

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 0.25 seconds
           Raw packets sent: 2 (68B) | Rcvd: 2 (68B)
</code></pre><p>The port shows up as <strong>unfiltered</strong>, because a <strong>TCP-RST</strong> was sent in response. Please note that it is not possible to identify ports that were not explicitely allowed, which means that an <strong>ACK-scan</strong> wouldn't bypass any intended rules. Nevertheless it's good to keep in mind that the rules added by ufw allow <strong>ACK-scans</strong> as well.</p>
<h2 id="security-implications-and-summary">Security implications and summary</h2>
<p>After providing this overview about default ufw rules and characteristics, what are the security implications?</p>
<p>First of all the default policy for incoming packets ensures that packets that were not explicitely allowed are dropped. There are some exclusions for <strong>RELATED</strong> and <strong>ESTABLISHED</strong> connections, some ICMP/ICMPv6 packets and applications like DHCP/DHCPv6, mDNS and SSDP/UPnP.</p>
<p>If these services are running and are either misconfigured or affected by vulnerabilities, the default rules could allow attacks against these services.</p>
<p>In post-exploitation scenarios attackers could use unfiltered ports to bind malicious services on them. Whether this is successful depends on the granted privileges, as binding on ports &lt; 1024 require either root privileges or the <strong>cap_net_bind_service</strong> capability.</p>
<p>As the ufw default ruleset allows almost all types of egress traffic, it would be easy to establish C2 communication after a successful compromise.</p>
<p>In this blog post only the default rules were inspected. Some additional rules could be added to the <strong>OUTPUT</strong> chain to further lock down the system, however the general ruleset offers a good baseline aready. Furthermore it should be noted that ufw still is an iptables frontend and not a firewall itself. For managing finegrained and advanced rules knowledge of iptables/netfilter is required.</p>
<h2 id="references">References</h2>
<p>[<a href="https://home.regit.org/netfilter-en/secure-use-of-helpers/">1</a>]: <a href="https://home.regit.org/netfilter-en/secure-use-of-helpers/">https://home.regit.org/netfilter-en/secure-use-of-helpers/</a></p>
<p>[<a href="https://github.com/torvalds/linux/commit/486dcf43da7815baa615822f3e46883ccca5400f">2</a>]: <a href="https://github.com/torvalds/linux/commit/486dcf43da7815baa615822f3e46883ccca5400f">https://github.com/torvalds/linux/commit/486dcf43da7815baa615822f3e46883ccca5400f</a></p>
<p>[<a href="https://www.ietf.org/rfc/rfc5095.txt">3</a>]: <a href="https://www.ietf.org/rfc/rfc5095.txt">https://www.ietf.org/rfc/rfc5095.txt</a></p>
<p>[<a href="https://www.ietf.org/rfc/rfc2461.txt">4</a>]: <a href="https://www.ietf.org/rfc/rfc2461.txt">https://www.ietf.org/rfc/rfc2461.txt</a></p>
<p>[<a href="https://www.ietf.org/rfc/rfc2710.txt">5</a>]: <a href="https://www.ietf.org/rfc/rfc2710.txt">https://www.ietf.org/rfc/rfc2710.txt</a></p>
<p>[<a href="https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt">6</a>]: <a href="https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt">https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt</a></p>

    </section>
    <footer class="post-footer">
      
    </footer>
  </article>
</main>

        <footer class="site-footer">
  <section class="rss"><a class="subscribe-button icon-feed" href="/index.xml"></a></section>
  <section class="twitter"><a class="icon-twitter" href="https://twitter.com/_bka_"> _bka_</a></section>
  
  <section class="copyright">&copy; 2022 blog.kanbach.org</section>
  <section class="poweredby"><a href="http://thedarkroast.com/arabica">Arabica</a> theme by Sean Lunsford. Published with <a href="https://gohugo.io">Hugo</a>.</section>
</footer>



    </body>
</html>
